<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®ãƒ‡ãƒ¼ã‚¿å–å¾—ï¼ˆã‚°ãƒŸç”¨ï¼‰</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Google Identity Services: OAuth 2.0 ãƒˆãƒ¼ã‚¯ãƒ³ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ -->
    <script async defer src="https://accounts.google.com/gsi/client"></script>
    <style>
      body {
        font-family: system-ui, sans-serif;
        margin: 2rem;
      }
      button {
        padding: 0.8rem 1.2rem;
        font-size: 1rem;
      }
      #output {
        background: #f4f4f8;
        padding: 1rem;
        overflow: auto;
        max-height: 600px;
        border-radius: 4px;
      }
      .month-section {
        margin-bottom: 1.5rem;
      }
      details {
        background: white;
        border-radius: 4px;
        padding: 0.5rem;
        margin-bottom: 0.5rem;
      }
      summary {
        cursor: pointer;
        font-weight: bold;
        color: #2563eb;
        padding: 0.5rem;
        user-select: none;
      }
      summary:hover {
        background: #f0f9ff;
        border-radius: 4px;
      }
      .event-list {
        list-style: none;
        padding: 0;
        margin: 0.5rem 0 0 0;
      }
      .event-item {
        padding: 0.5rem;
        border-bottom: 1px solid #e0e0e0;
        font-family: monospace;
      }
      .event-item:last-child {
        border-bottom: none;
      }
      .event-date {
        color: #2563eb;
        font-weight: bold;
        margin-right: 1rem;
      }
      .event-title {
        color: #1f2937;
      }
    </style>
  </head>
  <body>
    <h1>ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹</h1>
    <p>
      å¹´ã‚’é¸æŠã—ã¦ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨ã€ãã®å¹´ã® Google Calendar
      ã‚¤ãƒ™ãƒ³ãƒˆã‚’å–å¾—ã—ã¾ã™ï¼ˆèª­ã¿å–ã‚Šå°‚ç”¨ï¼‰ã€‚
    </p>

    <div style="margin-bottom: 1rem">
      <label for="year-select">å¹´ã‚’é¸æŠ: </label>
      <select id="year-select" style="padding: 0.5rem; font-size: 1rem">
        <option value="2023">2023</option>
        <option value="2024">2024</option>
        <option value="2025" selected>2025</option>
        <option value="2026">2026</option>
      </select>
    </div>

    <button id="fetch-btn">ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹</button>
    <button
      id="download-btn"
      style="
        display: none;
        margin-left: 0.5rem;
        background: #10b981;
        color: white;
      "
    >
      JSONãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
    </button>
    <p id="status"></p>

    <div
      id="filter-section"
      style="
        display: none;
        margin: 1rem 0;
        padding: 1rem;
        background: #e0f2fe;
        border-radius: 4px;
      "
    >
      <h3 style="margin-top: 0">ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼</h3>
      <div
        style="display: flex; gap: 1rem; flex-wrap: wrap; align-items: center"
      >
        <input
          id="q"
          type="text"
          placeholder="ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼ˆã‚¿ã‚¤ãƒˆãƒ«/èª¬æ˜/å ´æ‰€ï¼‰"
          style="padding: 0.5rem; font-size: 1rem; min-width: 250px"
        />
        <label style="display: flex; align-items: center; gap: 0.5rem">
          <input type="checkbox" id="allDayOnly" />
          <span>çµ‚æ—¥ã®äºˆå®šã®ã¿</span>
        </label>
        <button id="apply-filter" style="padding: 0.5rem 1rem">
          ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨
        </button>
        <button
          id="clear-filter"
          style="padding: 0.5rem 1rem; background: #e5e7eb"
        >
          ã‚¯ãƒªã‚¢
        </button>
      </div>
    </div>

    <div id="output"></div>

    <!-- ã‚°ãƒŸè½ä¸‹ãƒ‡ãƒ¢UI -->
    <div
      style="
        margin-top: 2rem;
        padding: 1rem;
        background: #fef3c7;
        border-radius: 4px;
      "
    >
      <h3 style="margin-top: 0">ã‚°ãƒŸå¯è¦–åŒ–</h3>
      <p style="margin: 0.5rem 0">
        è¡¨ç¤ºä¸­ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’ã‚°ãƒŸã«å¤‰æ›ã—ã¦è½ã¨ã—ã¾ã™ã€‚è‰²ã¯æ„Ÿæƒ…ã€ã‚µã‚¤ã‚ºã¯é‡ã¿ï¼ˆå‚åŠ è€…æ•°ãªã©ï¼‰ã‚’è¡¨ã—ã¾ã™ã€‚
      </p>

      <!-- æœˆåˆ¥ãƒ‰ãƒ­ãƒƒãƒ—UI -->
      <div
        style="
          margin-top: 1rem;
          display: flex;
          gap: 0.5rem;
          align-items: center;
          flex-wrap: wrap;
        "
      >
        <label for="month-select">æœˆï¼š</label>
        <select id="month-select" style="padding: 0.5rem; font-size: 1rem">
          <option value="01">01</option>
          <option value="02">02</option>
          <option value="03">03</option>
          <option value="04">04</option>
          <option value="05">05</option>
          <option value="06">06</option>
          <option value="07">07</option>
          <option value="08">08</option>
          <option value="09">09</option>
          <option value="10">10</option>
          <option value="11">11</option>
          <option value="12">12</option>
        </select>

        <button
          id="drop-month-btn"
          style="
            padding: 0.8rem 1.2rem;
            background: #f59e0b;
            color: white;
            font-weight: bold;
          "
        >
          ã“ã®æœˆã®ã‚°ãƒŸã‚’è½ã¨ã™
        </button>
        <button
          id="shower-btn"
          style="
            padding: 0.8rem 1.2rem;
            background: #8b5cf6;
            color: white;
            font-weight: bold;
          "
        >
          å¹´é–“ã‚°ãƒŸã‚·ãƒ£ãƒ¯ãƒ¼ï¼ˆ3ç§’/12å›ï¼‰
        </button>
      </div>

      <canvas
        id="gummy-canvas"
        width="900"
        height="500"
        style="
          border: 2px solid #d97706;
          margin-top: 0.5rem;
          display: block;
          border-radius: 4px;
          background: #fffbeb;
        "
      ></canvas>
    </div>

    <script type="module">
      // ã‚°ãƒ­ãƒ¼ãƒãƒ« familyCenterHue é–¢æ•°ï¼ˆè‰²ç›¸ãƒ•ã‚¡ãƒŸãƒªã®ä¸­å¿ƒå€¤ï¼‰
      function familyCenterHue(fam) {
        return (
          {
            red: 0,
            orange: 45,
            yellow: 75,
            green: 120,
            cyan: 180,
            blue: 240,
            purple: 300,
          }[fam] ?? 180
        );
      }
      // ã‚°ãƒ­ãƒ¼ãƒãƒ« hueFamily é–¢æ•°ï¼ˆè‰²ç›¸ãƒ•ã‚¡ãƒŸãƒªåˆ¤å®šï¼‰
      function hueFamily(h) {
        if (h < 30 || h >= 330) return "red";
        if (h < 60) return "orange";
        if (h < 90) return "yellow";
        if (h < 150) return "green";
        if (h < 210) return "cyan";
        if (h < 270) return "blue";
        return "purple";
      }
      // ã‚°ãƒ­ãƒ¼ãƒãƒ« diversifyColors é–¢æ•°ï¼ˆåŒç³»çµ±è‰²ã®ãƒãƒ©ã—ï¼‰
      function diversifyColors(gummies, opts = {}) {
        const {
          threshold = 0.6,
          jitterDeg = 22,
          satMin = 0.55,
          satMax = 0.9,
          lightMin = 0.45,
          lightMax = 0.65,
          useGoldenAngle = true,
        } = opts;

        const total = gummies.length || 1;
        const familiesCount = {};
        for (const g of gummies) {
          const h = g.hsl?.h ?? hueFromHex(g.color);
          const fam = hueFamily(h);
          familiesCount[fam] = (familiesCount[fam] || 0) + 1;
        }
        // æ”¯é…ãƒ•ã‚¡ãƒŸãƒªåˆ¤å®š
        let dominant = null,
          pDominant = 0;
        for (const [fam, count] of Object.entries(familiesCount)) {
          const p = count / total;
          if (p > pDominant) {
            pDominant = p;
            dominant = fam;
          }
        }
        if (!dominant || pDominant < threshold) return gummies; // é©ç”¨ãªã—

        const spread = 137.5; // é»„é‡‘è§’ã§ãƒãƒ©ã—
        let idx = 0;

        return gummies.map((g) => {
          const h0 = g.hsl?.h ?? hueFromHex(g.color);
          const fam = hueFamily(h0);
          if (fam !== dominant) return g; // æ”¯é…ãƒ•ã‚¡ãƒŸãƒªä»¥å¤–ã¯å¤‰æ›´ã—ãªã„

          const centerHue = familyCenterHue(fam);
          const jitter = useGoldenAngle
            ? ((idx++ * spread) % (jitterDeg * 2)) - jitterDeg
            : Math.random() * (jitterDeg * 2) - jitterDeg;

          const newH = wrapHue(centerHue + jitter);
          const newS = clamp(satMin + Math.random() * (satMax - satMin), 0, 1);
          const newL = clamp(
            lightMin + Math.random() * (lightMax - lightMin),
            0,
            1
          );

          const newHex = hslToHex(newH, newS, newL);
          return { ...g, color: newHex, hsl: { h: newH, s: newS, l: newL } };
        });
      }
      // ã‚°ãƒ­ãƒ¼ãƒãƒ«wrapHueé–¢æ•°ï¼ˆ360åº¦ç’°ã§å€¤ã‚’æ­£è¦åŒ–ï¼‰
      function wrapHue(h) {
        return ((h % 360) + 360) % 360;
      }
      // ã‚°ãƒ­ãƒ¼ãƒãƒ«clampé–¢æ•°ï¼ˆmin/maxç¯„å›²ã§å€¤ã‚’åˆ¶é™ï¼‰
      function clamp(x, min, max) {
        return Math.max(min, Math.min(max, x));
      }
      // â˜…â˜… ã“ã“ã‚’æ›¸ãæ›ãˆã‚‹ â˜…â˜…
      const CLIENT_ID = import.meta.env.VITE_GOOGLE_CLIENT_ID; // Cloud Consoleã§ç™ºè¡Œã•ã‚ŒãŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆID
      const SCOPES = "https://www.googleapis.com/auth/calendar.readonly";

      // ä»Šå¹´ã®ç¯„å›²ã‚’ISOæ–‡å­—åˆ—ï¼ˆUTCï¼‰ã§ä½œæˆ
      function getYearRangeUTC(year = new Date().getFullYear()) {
        const timeMin = new Date(Date.UTC(year, 0, 1, 0, 0, 0)).toISOString();
        const timeMax = new Date(
          Date.UTC(year, 11, 31, 23, 59, 59)
        ).toISOString();
        return { timeMin, timeMax, year };
      }

      // çŠ¶æ…‹è¡¨ç¤ºç”¨
      const $status = document.getElementById("status");
      const $output = document.getElementById("output");
      const $btn = document.getElementById("fetch-btn");
      const $downloadBtn = document.getElementById("download-btn");
      const $yearSelect = document.getElementById("year-select");
      const $filterSection = document.getElementById("filter-section");
      const $applyFilter = document.getElementById("apply-filter");
      const $clearFilter = document.getElementById("clear-filter");
      const $q = document.getElementById("q");
      const $allDayOnly = document.getElementById("allDayOnly");

      let tokenClient = null;
      let accessToken = null;
      let pendingTokenRequest = null;
      let allEvents = []; // å–å¾—ã—ãŸå…¨ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä¿æŒ
      let currentDisplayedEvents = []; // ç¾åœ¨è¡¨ç¤ºä¸­ã®ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å¾Œï¼‰

      function setStatus(msg) {
        $status.textContent = msg;
      }

      function formatEventDate(ev) {
        // çµ‚æ—¥äºˆå®š: start.date ã®ã¿å­˜åœ¨
        if (ev.start?.date && !ev.start?.dateTime) {
          return ev.start.date; // YYYY-MM-DD ã‚’ãã®ã¾ã¾è¿”ã™
        }
        // æ™‚é–“æŒ‡å®šäºˆå®š: start.dateTime å­˜åœ¨
        if (ev.start?.dateTime) {
          const d = new Date(ev.start.dateTime);
          const yyyy = d.getFullYear();
          const mm = String(d.getMonth() + 1).padStart(2, "0");
          const dd = String(d.getDate()).padStart(2, "0");
          return `${yyyy}-${mm}-${dd}`;
        }
        return "";
      }

      function groupByMonth(events) {
        const map = new Map(); // key: 'YYYY-MM', value: array of events
        for (const ev of events) {
          const dateStr = formatEventDate(ev);
          if (!dateStr) continue;
          const ym = dateStr.slice(0, 7); // YYYY-MM
          if (!map.has(ym)) map.set(ym, []);
          map.get(ym).push(ev);
        }
        return map;
      }

      function applyFilter(events) {
        const q = $q.value.trim().toLowerCase();
        const allDayOnly = $allDayOnly.checked;

        return events.filter((ev) => {
          // çµ‚æ—¥åˆ¤å®š: start.date ãŒã‚ã£ã¦ start.dateTime ãŒãªã„
          const isAllDay = !!ev.start?.date && !ev.start?.dateTime;
          if (allDayOnly && !isAllDay) return false;

          // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ¤œç´¢
          if (q) {
            const text = [
              ev.summary || "",
              ev.description || "",
              ev.location || "",
            ]
              .join(" ")
              .toLowerCase();
            if (!text.includes(q)) return false;
          }

          return true;
        });
      }

      function downloadJSON(data, filename = "calendar-events.json") {
        const blob = new Blob([JSON.stringify(data, null, 2)], {
          type: "application/json",
        });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.click();
        URL.revokeObjectURL(a.href);
      }

      function displayEvents(events) {
        currentDisplayedEvents = events; // ç¾åœ¨è¡¨ç¤ºä¸­ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä¿å­˜

        if (events.length === 0) {
          $output.innerHTML =
            '<p style="color: #6b7280;">ã‚¤ãƒ™ãƒ³ãƒˆãŒã‚ã‚Šã¾ã›ã‚“</p>';
          return;
        }

        const monthly = groupByMonth(events);
        const months = Array.from(monthly.keys()).sort();

        const html = months
          .map((ym) => {
            const monthEvents = monthly.get(ym);
            const count = monthEvents.length;

            const eventItems = monthEvents
              .map((ev) => {
                const dateStr = formatEventDate(ev) || "æ—¥ä»˜ä¸æ˜";
                const title = ev.summary || "(ã‚¿ã‚¤ãƒˆãƒ«ãªã—)";
                // çµ‚æ—¥ã‹ã©ã†ã‹ã‚’è¡¨ç¤ºã«åæ˜ 
                const isAllDay = !!ev.start?.date && !ev.start?.dateTime;
                const timeMarker = isAllDay ? " [çµ‚æ—¥]" : "";

                return `<li class="event-item">
                <span class="event-date">${dateStr}</span> | <span class="event-title">${title}${timeMarker}</span>
              </li>`;
              })
              .join("");

            return `<section class="month-section">
            <details open>
              <summary>${ym} | ${count}ä»¶</summary>
              <ul class="event-list">
                ${eventItems}
              </ul>
            </details>
          </section>`;
          })
          .join("");

        $output.innerHTML = html;
      }

      function initTokenClient() {
        if (tokenClient) return;
        tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: CLIENT_ID,
          scope: SCOPES,
          callback: (resp) => {
            if (resp.error) {
              setStatus("èªè¨¼ã‚¨ãƒ©ãƒ¼: " + resp.error);
              console.error(resp);
              if (pendingTokenRequest) {
                pendingTokenRequest.reject(new Error(resp.error));
                pendingTokenRequest = null;
              }
            } else {
              accessToken = resp.access_token;
              if (pendingTokenRequest) {
                pendingTokenRequest.resolve(resp.access_token);
                pendingTokenRequest = null;
              }
            }
          },
        });
      }

      async function ensureAccessToken() {
        if (accessToken) return accessToken;

        // Initialize token client if needed
        if (!tokenClient) {
          initTokenClient();
        }

        // Create promise to wait for callback
        return new Promise((resolve, reject) => {
          pendingTokenRequest = { resolve, reject };

          // Check if already has token
          if (accessToken) {
            tokenClient.requestAccessToken({ prompt: "" });
          } else {
            tokenClient.requestAccessToken({ prompt: "consent" });
          }

          // Timeout after 60 seconds
          setTimeout(() => {
            if (pendingTokenRequest) {
              pendingTokenRequest.reject(
                new Error("èªè¨¼ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ")
              );
              pendingTokenRequest = null;
            }
          }, 60000);
        });
      }

      async function fetchEventsForYear(year) {
        const { timeMin, timeMax } = getYearRangeUTC(year);
        const token = await ensureAccessToken();

        const params = new URLSearchParams({
          timeMin,
          timeMax,
          singleEvents: "true",
          orderBy: "startTime",
          maxResults: "2500", // å¹´é–“æœ€å¤§ä»¶æ•°ã®ç›®å®‰
        });

        const url = `https://www.googleapis.com/calendar/v3/calendars/primary/events?${params.toString()}`;
        const res = await fetch(url, {
          headers: { Authorization: `Bearer ${token}` },
        });

        if (!res.ok) {
          const errText = await res.text();
          throw new Error(`Calendar API ã‚¨ãƒ©ãƒ¼ (${res.status}): ${errText}`);
        }
        const data = await res.json();
        return data.items ?? [];
      }

      $btn.addEventListener("click", async () => {
        setStatus("èªè¨¼ã—ã¦ã„ã¾ã™â€¦");
        try {
          await ensureAccessToken();
          setStatus("ãƒ‡ãƒ¼ã‚¿å–å¾—ä¸­â€¦");
          const year = parseInt($yearSelect.value); // é¸æŠã•ã‚ŒãŸå¹´ã‚’å–å¾—
          const events = await fetchEventsForYear(year);
          allEvents = events; // å…¨ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä¿å­˜
          setStatus(`å–å¾—å®Œäº†ï¼š${events.length}ä»¶ï¼ˆ${year}å¹´ï¼‰`);

          // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¨ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
          $filterSection.style.display = "block";
          $downloadBtn.style.display = "inline-block";

          displayEvents(events);
        } catch (e) {
          console.error(e);
          setStatus("å¤±æ•—ï¼š" + e.message);
        }
      });

      $downloadBtn.addEventListener("click", () => {
        const year = parseInt($yearSelect.value);
        const filename = `calendar-events-${year}.json`;
        downloadJSON(currentDisplayedEvents, filename);
        setStatus(
          `ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†ï¼š${currentDisplayedEvents.length}ä»¶ã‚’ ${filename} ã¨ã—ã¦ä¿å­˜`
        );
      });

      $applyFilter.addEventListener("click", () => {
        const filtered = applyFilter(allEvents);
        setStatus(
          `ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨ï¼š${filtered.length}ä»¶ / ${allEvents.length}ä»¶`
        );
        displayEvents(filtered);
      });

      $clearFilter.addEventListener("click", () => {
        $q.value = "";
        $allDayOnly.checked = false;
        setStatus(`å–å¾—å®Œäº†ï¼š${allEvents.length}ä»¶`);
        displayEvents(allEvents);
      });

      // Enterã‚­ãƒ¼ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨
      $q.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          $applyFilter.click();
        }
      });

      // =========================
      // ã‚°ãƒŸè½ä¸‹æ©Ÿèƒ½
      // =========================

      // ====== æ„Ÿæƒ…ã‚¹ã‚³ã‚¢å¼·åŒ–ï¼ˆè¾æ›¸ï¼‹HSLï¼‰ ======

      // æ—¥æœ¬èªè¾æ›¸ï¼ˆå¿…è¦ã«å¿œã˜ã¦è‡ªç”±ã«è¿½åŠ ã—ã¦OKï¼‰
      const LEXICON = {
        joy: [
          /ã†ã‚Œã—ã„|å¬‰ã—ã„|æ¥½ã—ã„|ãƒãƒƒãƒ”ãƒ¼|æœ€é«˜|ã‚„ã£ãŸ|æ­“å–œ|ç¥|å‹åˆ©|é”æˆ|å……å®Ÿ|å–œã³/i,
          /ğŸ˜Š|ğŸ˜„|ğŸ¥³|âœ¨|ğŸ‰|ğŸŠ/,
        ],
        calm: [
          /ç©ã‚„ã‹|ä¼‘æ†©|ãƒªãƒ©ãƒƒã‚¯ã‚¹|è½ã¡ç€|é™ã‹|ã®ã‚“ã³ã‚Š|ç™’ã—|ç‘æƒ³|æ•£æ­©|æ¸©æ³‰|ã‚«ãƒ•ã‚§|å®‰å®š/i,
          /ğŸ˜Œ|ğŸŒ¿|ğŸ«–|â˜•|ğŸ›€|ğŸŒ™/,
        ],
        busy: [
          /å¿™|ä¿®ç¾…å ´|ç· åˆ‡|ç· ã‚åˆ‡ã‚Š|ãƒ‡ãƒƒãƒ‰ãƒ©ã‚¤ãƒ³|rush|ãƒã‚¿ãƒã‚¿|æ®‹æ¥­|å¯¾å¿œ|ãƒˆãƒ©ãƒ–ãƒ«|ç‚ä¸Š|ã¦ã‚“ã¦ã“èˆã„/i,
          /â°|ğŸ”¥|ğŸ’¦|ğŸ“ˆ/,
        ],
        focus: [
          /é›†ä¸­|æ²¡é ­|æ·±æ˜ã‚Š|ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°|å®Ÿè£…|è¨­è¨ˆ|ç ”ç©¶|è«–æ–‡|å­¦ç¿’|å‹‰å¼·|æ¼”ç¿’|ä½œæ¥­|åŸ·ç­†|ãƒ¬ãƒ“ãƒ¥ãƒ¼|ãƒ†ã‚¹ãƒˆ/i,
          /ğŸ¯|ğŸ§ |ğŸ§ª|âŒ¨ï¸|ğŸ“/,
        ],
        stress: [
          /ã‚¹ãƒˆãƒ¬ã‚¹|ç–²åŠ´|ç„¦ã‚Š|ä¸å®‰|ãƒŸã‚¹|å¤±æ•—|æ€’ã‚Š|ã„ã‚‰ã„ã‚‰|æ‚²|ã¤ã‚‰|è½ã¡è¾¼|ã—ã‚“ã©|æ†‚é¬±/i,
          /ğŸ˜£|ğŸ˜¡|ğŸ˜¢|ğŸ’€|ğŸŒ€/,
        ],
      };

      // æ„Ÿæƒ…ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ï¼šãƒ†ã‚­ã‚¹ãƒˆ â†’ {joy, calm, busy, focus, stress, intensity}
      function scoreEmotion(text) {
        const lower = text.toLowerCase();
        const scores = { joy: 0, calm: 0, busy: 0, focus: 0, stress: 0 };

        for (const [key, patterns] of Object.entries(LEXICON)) {
          for (const re of patterns) {
            // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒè¤‡æ•°å›å‡ºã‚‹ã»ã©ã‚¹ã‚³ã‚¢åŠ ç®—
            const matches = lower.match(re);
            if (matches) scores[key] += matches.length;
          }
        }

        // ï¼ã‚„çµµæ–‡å­—ã®å¼·åº¦è£œæ­£ï¼ˆç°¡æ˜“ï¼‰
        const emphasis = text.match(/[!ï¼]/g)?.length || 0;
        const emojiBoost =
          (text.match(/[\u{1F300}-\u{1FAFF}]/gu)?.length || 0) * 0.5;
        const boost = Math.min(3, emphasis * 0.2 + emojiBoost);

        for (const k of Object.keys(scores)) scores[k] += boost;

        // ç·å¼·åº¦ï¼ˆæœ€å¤§ï¼‰ã‚’ 0..1 ã«æ­£è¦åŒ–
        const maxScore = Math.max(...Object.values(scores));
        const intensity = Math.min(1, maxScore / 5); // ã ã„ãŸã„5å›å‡ºç¾ã§å¼·ã‚æ‰±ã„
        return { ...scores, intensity };
      }

      // HSLãƒãƒƒãƒ”ãƒ³ã‚°ï¼šå„æ„Ÿæƒ…è»¸ã®è‰²ç›¸ã‚’ãƒ™ã‚¯ãƒˆãƒ«å¹³å‡ â†’ é€£ç¶šHue
      const BASE_HUE = {
        joy: 50, // é»„
        calm: 200, // é’
        busy: 0, // èµ¤
        focus: 120, // ç·‘
        stress: 300, // ãƒã‚¼ãƒ³ã‚¿
      };

      // Hueãƒ™ã‚¯ãƒˆãƒ«å¹³å‡ï¼ˆå††ç’°è£œæ­£ã‚ã‚Šï¼‰ã€å½©åº¦/æ˜åº¦ã¯æ–‡è„ˆã§èª¿æ•´
      function colorFromEmotionScores(scores, ctx = {}) {
        // ctx: { isAllDay, attendees, durationHours }
        const weights = Object.entries(scores)
          .filter(([k]) => k in BASE_HUE)
          .map(([k, v]) => ({ k, w: v }));

        const totalW = weights.reduce((a, b) => a + b.w, 0) || 1;
        // ãƒ™ã‚¯ãƒˆãƒ«å’Œï¼ˆå††ç’°ï¼‰
        let vx = 0,
          vy = 0;
        for (const { k, w } of weights) {
          const hue = (BASE_HUE[k] * Math.PI) / 180;
          vx += Math.cos(hue) * (w / totalW);
          vy += Math.sin(hue) * (w / totalW);
        }
        let hueDeg = (Math.atan2(vy, vx) * 180) / Math.PI;
        if (hueDeg < 0) hueDeg += 360;

        // å½©åº¦ï¼šå¼·åº¦ãƒ™ãƒ¼ã‚¹ï¼ˆå¼±â†’0.35, å¼·â†’0.9ï¼‰
        let s = 0.35 + scores.intensity * 0.55;
        let l = 0.55;

        // æš–è‰²åŸŸï¼ˆèµ¤ã€œé»„ï¼‰ã¯æœ€ä½å½©åº¦ãƒ»æ˜åº¦ã‚’å¼•ãä¸Šã’
        const isWarm = hueDeg >= 15 && hueDeg <= 75;
        if (isWarm) {
          s = Math.max(s, 0.6);
          l = Math.max(l, 0.5);
        }
        // å¼·åº¦ã§å½©åº¦ã‚’ã‚‚ã†ä¸€æ®µãƒ–ãƒ¼ã‚¹ãƒˆ
        s = clamp(s + scores.intensity * 0.1, 0, 1);

        // çµ‚æ—¥ãƒ»å‚åŠ è€…ãƒ»æ™‚é–“ã«ã‚ˆã‚‹æ˜åº¦èª¿æ•´
        const isAllDay = !!ctx.isAllDay;
        const attendees = Math.min(10, ctx.attendees || 0);
        const duration = Math.min(12, ctx.durationHours || 0);
        if (isAllDay) l = clamp(l + 0.05, 0, 1);
        l = clamp(l - attendees * 0.01 - duration * 0.008, 0.35, 0.75);

        const hex = hslToHex(wrapHue(hueDeg), s, l);
        return { hex, h: wrapHue(hueDeg), s, l };
      }

      // HSL â†’ HEX
      function hslToHex(h, s, l) {
        s = Math.max(0, Math.min(1, s));
        l = Math.max(0, Math.min(1, l));
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const hp = (h % 360) / 60;
        const x = c * (1 - Math.abs((hp % 2) - 1));
        let r1 = 0,
          g1 = 0,
          b1 = 0;
        if (0 <= hp && hp < 1) {
          r1 = c;
          g1 = x;
          b1 = 0;
        } else if (1 <= hp && hp < 2) {
          r1 = x;
          g1 = c;
          b1 = 0;
        } else if (2 <= hp && hp < 3) {
          r1 = 0;
          g1 = c;
          b1 = x;
        } else if (3 <= hp && hp < 4) {
          r1 = 0;
          g1 = x;
          b1 = c;
        } else if (4 <= hp && hp < 5) {
          r1 = x;
          g1 = 0;
          b1 = c;
        } else {
          r1 = c;
          g1 = 0;
          b1 = x;
        }
        const m = l - c / 2;
        const r = Math.round((r1 + m) * 255);
        const g = Math.round((g1 + m) * 255);
        const b = Math.round((b1 + m) * 255);
        return `#${[r, g, b]
          .map((v) => v.toString(16).padStart(2, "0"))
          .join("")}`;
      }

      // === toGummies ã‚’å¼·åŒ–ï¼ˆè¾æ›¸ã‚¹ã‚³ã‚¢â†’HSLè‰²ï¼‰ ===
      function toGummies(events) {
        return events.map((ev) => {
          const title = ev.summary || "";
          const text = [title, ev.description || "", ev.location || ""].join(
            " "
          );
          const isAllDay = !!ev.start?.date && !ev.start?.dateTime;
          const attendees = ev.attendees?.length || 0;
          let durationHours = 0;
          if (ev.start?.dateTime && ev.end?.dateTime) {
            const start = new Date(ev.start.dateTime).getTime();
            const end = new Date(ev.end.dateTime).getTime();
            durationHours = Math.max(0, (end - start) / 3600000);
          }
          const scores = scoreEmotion(text);
          const col = colorFromEmotionScores(scores, {
            isAllDay,
            attendees,
            durationHours,
          });
          const lower = text.toLowerCase();
          const kind = /mtg|ä¼šè­°|meeting/.test(lower)
            ? "meeting"
            : /å‹‰å¼·|è¬›ç¾©|study|learn/.test(lower)
            ? "study"
            : /é–‹ç™º|å®Ÿè£…|ã‚³ãƒ¼ãƒ‰|code|task|ä½œæ¥­|èª²é¡Œ/.test(lower)
            ? "work"
            : /ä¼‘æš‡|æ—…è¡Œ|å®¶æ—|è²·ã„ç‰©|ç”Ÿæ´»|life/.test(lower)
            ? "life"
            : "other";
          const baseWeight = isAllDay ? 0.9 : 1.0;
          const weight = Math.min(
            4,
            baseWeight +
              Math.log2(attendees + 1) +
              Math.min(1.5, durationHours / 6)
          );
          return {
            id: ev.id,
            date: formatEventDate(ev),
            kind,
            title,
            emotionScores: scores,
            color: col.hex,
            hsl: { h: col.h, s: col.s, l: col.l },
            weight,
          };
        });
        // HEX â†’ HSLï¼ˆHã ã‘å¿…è¦ãªã‚‰ç°¡æ˜“ã§ã‚‚OKï¼‰
        function hexToRgb(hex) {
          const m = hex.replace("#", "").match(/.{1,2}/g);
          if (!m) return [0, 0, 0];
          return m.map((x) => parseInt(x, 16));
        }
        function rgbToHsl(r, g, b) {
          r /= 255;
          g /= 255;
          b /= 255;
          const max = Math.max(r, g, b),
            min = Math.min(r, g, b);
          let h,
            s,
            l = (max + min) / 2;
          const d = max - min;
          if (d === 0) {
            h = 0;
            s = 0;
          } else {
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
              case r:
                h = (g - b) / d + (g < b ? 6 : 0);
                break;
              case g:
                h = (b - r) / d + 2;
                break;
              case b:
                h = (r - g) / d + 4;
                break;
            }
            h *= 60;
          }
          return { h, s, l };
        }
        const hueFromHex = (hex) => rgbToHsl(...hexToRgb(hex)).h;

        // è‰²ç›¸ãƒ•ã‚¡ãƒŸãƒªåˆ¤å®š
        function hueFamily(h) {
          if (h < 30 || h >= 330) return "red";
          if (h < 60) return "orange";
          if (h < 90) return "yellow";
          if (h < 150) return "green";
          if (h < 210) return "cyan";
          if (h < 270) return "blue";
          return "purple";
        }
        function familyCenterHue(fam) {
          return (
            {
              red: 0,
              orange: 45,
              yellow: 75,
              green: 120,
              cyan: 180,
              blue: 240,
              purple: 300,
            }[fam] ?? 180
          );
        }

        // â˜… åŒç³»çµ± 6å‰²ä»¥ä¸Šãªã‚‰â€œãƒãƒ©ã—â€ã‚’é©ç”¨
        function diversifyColors(gummies, opts = {}) {
          const {
            threshold = 0.6,
            jitterDeg = 22,
            satMin = 0.55,
            satMax = 0.9,
            lightMin = 0.45,
            lightMax = 0.65,
            useGoldenAngle = true,
          } = opts;

          const total = gummies.length || 1;
          const familiesCount = {};
          for (const g of gummies) {
            const h = g.hsl?.h ?? hueFromHex(g.color);
            const fam = hueFamily(h);
            familiesCount[fam] = (familiesCount[fam] || 0) + 1;
          }
          // æ”¯é…ãƒ•ã‚¡ãƒŸãƒªåˆ¤å®š
          let dominant = null,
            pDominant = 0;
          for (const [fam, count] of Object.entries(familiesCount)) {
            const p = count / total;
            if (p > pDominant) {
              pDominant = p;
              dominant = fam;
            }
          }
          if (!dominant || pDominant < threshold) return gummies; // é©ç”¨ãªã—

          const spread = 137.5; // é»„é‡‘è§’ã§ãƒãƒ©ã—
          let idx = 0;

          return gummies.map((g) => {
            const h0 = g.hsl?.h ?? hueFromHex(g.color);
            const fam = hueFamily(h0);
            if (fam !== dominant) return g; // æ”¯é…ãƒ•ã‚¡ãƒŸãƒªä»¥å¤–ã¯å¤‰æ›´ã—ãªã„

            const centerHue = familyCenterHue(fam);
            const jitter = useGoldenAngle
              ? ((idx++ * spread) % (jitterDeg * 2)) - jitterDeg
              : Math.random() * (jitterDeg * 2) - jitterDeg;

            const newH = wrapHue(centerHue + jitter);
            const newS = clamp(
              satMin + Math.random() * (satMax - satMin),
              0,
              1
            );
            const newL = clamp(
              lightMin + Math.random() * (lightMax - lightMin),
              0,
              1
            );

            const newHex = hslToHex(newH, newS, newL);
            return { ...g, color: newHex, hsl: { h: newH, s: newS, l: newL } };
          });
        }
      }

      // ä¹±æ•°ï¼ˆæ­£è¦åˆ†å¸ƒï¼‰Box-Muller
      function randNormal(mean = 0, stdDev = 1) {
        const u = 1 - Math.random();
        const v = 1 - Math.random();
        const z = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
        return mean + z * stdDev;
      }

      // æœˆã‚­ãƒ¼å–å¾—ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£
      function monthKeyFromEvent(ev) {
        const d = formatEventDate(ev); // YYYY-MM-DD
        return d ? d.slice(0, 7) : ""; // YYYY-MM
      }

      // ========== è¿½åŠ æŠ•å…¥å‹ ç‰©ç†ã‚¨ãƒ³ã‚¸ãƒ³ï¼ˆGummyWorldï¼‰ ==========
      // å††ã‚°ãƒŸã®è¡çªãƒ»åºŠãƒ»å£ã‚ã‚Šï¼å¾Œã‹ã‚‰ç²’ã‚’è¶³ã›ã‚‹
      function startGummyWorld(canvasId, options = {}) {
        const canvas = document.getElementById(canvasId);
        /** @type {CanvasRenderingContext2D} */
        const ctx = canvas.getContext("2d");
        const W = canvas.width,
          H = canvas.height;

        const cfg = {
          gravity: 0.45,
          air: 0.995,
          restitution: 0.22,
          frictionTangent: 0.02,
          centerBias: 0.12, // ä¸­å¤®å¯„ã›ã®å¼·ã•ï¼ˆæ­£è¦åˆ†å¸ƒã®Ïƒï¼šç”»é¢å¹…Ã—ã“ã®æ¯”ç‡ï¼‰
          maxParticles: 1000,
          cellSize: 24,
          ...options,
        };

        const particles = [];
        const floorY = H - 10;
        const leftX = 0,
          rightX = W;
        const cx = W / 2;

        const clamp = (x, min, max) => Math.max(min, Math.min(max, x));

        // ã‚°ãƒŸã‚’ç²’ã¨ã—ã¦è¿½åŠ ï¼ˆå¾Œã‹ã‚‰ä½•åº¦ã§ã‚‚å‘¼ã¹ã‚‹ï¼‰
        function addGummies(gummies) {
          const sigmaX = W * cfg.centerBias;
          for (const g of gummies) {
            const x = clamp(cx + randNormal(0, sigmaX), 20, W - 20);
            particles.push({
              x,
              y: -Math.random() * 200 - 20,
              vx: (Math.random() - 0.5) * 0.25,
              vy: 0,
              r: Math.max(6, 5 + g.weight * 3),
              m: Math.max(1, g.weight),
              color: g.color,
              kind: g.kind,
            });
          }
          if (particles.length > cfg.maxParticles) {
            // å¤ã„ç²’ã‚’æ¨ã¦ã‚‹
            particles.splice(0, particles.length - cfg.maxParticles);
          }
        }

        // ç©ºé–“åˆ†å‰²ã‚°ãƒªãƒƒãƒ‰
        const neighbors = [
          [0, 0],
          [1, 0],
          [0, 1],
          [1, 1],
          [-1, 0],
          [0, -1],
          [-1, -1],
          [1, -1],
          [-1, 1],
        ];
        function buildGrid() {
          const grid = new Map();
          const cellSize = cfg.cellSize;
          for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            const ix = Math.floor(p.x / cellSize);
            const iy = Math.floor(p.y / cellSize);
            const key = `${ix},${iy}`;
            let arr = grid.get(key);
            if (!arr) {
              arr = [];
              grid.set(key, arr);
            }
            arr.push(i);
          }
          return grid;
        }

        function resolvePair(p, q) {
          const dx = q.x - p.x;
          const dy = q.y - p.y;
          const dist2 = dx * dx + dy * dy;
          const rSum = p.r + q.r;
          if (dist2 <= 0) return;
          if (dist2 < rSum * rSum) {
            const dist = Math.sqrt(dist2) || 0.0001;
            const nx = dx / dist,
              ny = dy / dist;
            const overlap = rSum - dist;

            const totalM = p.m + q.m;
            const pushP = overlap * (q.m / totalM);
            const pushQ = overlap * (p.m / totalM);
            p.x -= nx * pushP;
            p.y -= ny * pushP;
            q.x += nx * pushQ;
            q.y += ny * pushQ;

            const rvx = q.vx - p.vx;
            const rvy = q.vy - p.vy;
            const relN = rvx * nx + rvy * ny;
            if (relN < 0) {
              const e = cfg.restitution;
              const j = (-(1 + e) * relN) / (1 / p.m + 1 / q.m);
              const jx = j * nx,
                jy = j * ny;
              p.vx -= jx / p.m;
              p.vy -= jy / p.m;
              q.vx += jx / q.m;
              q.vy += jy / q.m;

              // æ¥ç·šæ–¹å‘ã®ç°¡æ˜“æ‘©æ“¦
              const tx = -ny,
                ty = nx;
              const relT = rvx * tx + rvy * ty;
              const jt = Math.max(
                -cfg.frictionTangent,
                Math.min(cfg.frictionTangent, relT)
              );
              const jtx = jt * tx,
                jty = jt * ty;
              p.vx -= jtx / p.m;
              p.vy -= jty / p.m;
              q.vx += jtx / q.m;
              q.vy += jty / q.m;
            }
          }
        }

        function physicsStep(dt = 1) {
          // é‡åŠ›ãƒ»æ¸›è¡°ãƒ»ç§»å‹•
          for (const p of particles) {
            p.vy += cfg.gravity * dt;
            p.vx *= cfg.air;
            p.vy *= cfg.air;
            p.x += p.vx * dt;
            p.y += p.vy * dt;

            // å£ãƒ»åºŠ
            if (p.x - p.r < leftX) {
              p.x = leftX + p.r;
              p.vx *= -cfg.restitution;
            } else if (p.x + p.r > rightX) {
              p.x = rightX - p.r;
              p.vx *= -cfg.restitution;
            }
            if (p.y + p.r > floorY) {
              p.y = floorY - p.r;
              p.vy *= -cfg.restitution;
              if (Math.abs(p.vy) < 0.25) p.vy = 0;
            }
          }

          // è¡çªï¼ˆè¿‘å‚ï¼‰
          const grid = buildGrid();
          for (const [key, indices] of grid.entries()) {
            const [ix, iy] = key.split(",").map(Number);
            for (const [dx, dy] of neighbors) {
              const nk = `${ix + dx},${iy + dy}`;
              const neigh = grid.get(nk);
              if (!neigh) continue;
              for (const i of indices) {
                for (const j of neigh) {
                  if (j <= i) continue;
                  resolvePair(particles[i], particles[j]);
                }
              }
            }
          }
        }

        function draw() {
          ctx.clearRect(0, 0, W, H);
          // åºŠ
          ctx.fillStyle = "#eee";
          ctx.fillRect(0, floorY, W, H - floorY);

          // ç²’
          for (const p of particles) {
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.fill();

            // ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            ctx.fillStyle = "rgba(255,255,255,0.35)";
            ctx.beginPath();
            ctx.arc(
              p.x - p.r * 0.4,
              p.y - p.r * 0.45,
              p.r * 0.28,
              0,
              Math.PI * 2
            );
            ctx.fill();
          }
        }

        function loop() {
          physicsStep(1);
          draw();
          window.__gummyRAF = requestAnimationFrame(loop);
        }
        // å¤šé‡ãƒ«ãƒ¼ãƒ—é˜²æ­¢
        if (window.__gummyRAF) cancelAnimationFrame(window.__gummyRAF);
        loop();

        return {
          addGummies,
          clear: () => {
            particles.length = 0;
          },
        };
      }

      // ========== GummyWorldåˆæœŸåŒ– ==========
      window.__world =
        window.__world ||
        startGummyWorld("gummy-canvas", {
          centerBias: 0.12,
          restitution: 0.22,
          maxParticles: 1000,
        });

      // ========== "æœˆã ã‘è½ã¨ã™"ï¼†"å¹´é–“ã‚·ãƒ£ãƒ¯ãƒ¼" ãƒœã‚¿ãƒ³é…ç·š ==========
      const $monthSelect = document.getElementById("month-select");
      const $dropMonthBtn = document.getElementById("drop-month-btn");
      const $showerBtn = document.getElementById("shower-btn");

      // ã“ã®æœˆã ã‘è½ã¨ã™
      $dropMonthBtn.addEventListener("click", () => {
        const year = parseInt($yearSelect.value, 10);
        const mm = $monthSelect.value; // '01'..'12'
        const key = `${year}-${mm}`;

        const events = currentDisplayedEvents.filter(
          (ev) => monthKeyFromEvent(ev) === key
        );
        if (!events.length) {
          alert(`${key} ã®ã‚¤ãƒ™ãƒ³ãƒˆãŒã‚ã‚Šã¾ã›ã‚“ï¼ˆãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ä¸­ã‹ã‚‚ï¼‰ã€‚`);
          return;
        }
        let gummies = toGummies(events);
        gummies = diversifyColors(gummies, { threshold: 0.6, jitterDeg: 22 });
        window.__world.addGummies(gummies);
        setStatus(
          `${key} ã®ã‚°ãƒŸã‚’è¿½åŠ ï¼š${gummies.length}å€‹ã®ã‚°ãƒŸã‚’è½ã¨ã—ã¾ã—ãŸï¼`
        );
      });

      // å¹´é–“ã‚°ãƒŸã‚·ãƒ£ãƒ¯ãƒ¼ï¼š3ç§’ / 12å›ï¼ˆç´„250msã”ã¨ã«å„æœˆã‚’ä¸€å¡Šãšã¤ï¼‰
      $showerBtn.addEventListener("click", () => {
        const year = parseInt($yearSelect.value, 10);

        // ç¾åœ¨ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’æœˆåˆ¥ã«
        const monthlyMap = groupByMonth(currentDisplayedEvents);
        const months = Array.from({ length: 12 }, (_, i) =>
          String(i + 1).padStart(2, "0")
        );
        const batchKeys = months.map((m) => `${year}-${m}`);

        const totalMs = 3000;
        const intervalMs = Math.floor(totalMs / 12); // â‰ˆ 250ms
        let i = 0;

        // é€£æ‰“é˜²æ­¢ï¼ˆæ—¢å­˜ã‚¿ã‚¤ãƒãƒ¼ãŒã‚ã‚Œã°æ­¢ã‚ã‚‹ï¼‰
        if (window.__gummyTimer) clearInterval(window.__gummyTimer);

        setStatus(`å¹´é–“ã‚°ãƒŸã‚·ãƒ£ãƒ¯ãƒ¼é–‹å§‹ï¼š3ç§’ã§12ãƒ¶æœˆåˆ†ã‚’æŠ•ä¸‹ã—ã¾ã™...`);

        window.__gummyTimer = setInterval(() => {
          if (i >= batchKeys.length) {
            clearInterval(window.__gummyTimer);
            window.__gummyTimer = null;
            setStatus(`å¹´é–“ã‚°ãƒŸã‚·ãƒ£ãƒ¯ãƒ¼å®Œäº†ï¼`);
            return;
          }
          const key = batchKeys[i++];
          const batchEvents = monthlyMap.get(key) || [];
          if (batchEvents.length) {
            let batchGummies = toGummies(batchEvents);
            batchGummies = diversifyColors(batchGummies, {
              threshold: 0.6,
              jitterDeg: 22,
            });
            window.__world.addGummies(batchGummies);
          }
          // ã‚¤ãƒ™ãƒ³ãƒˆãŒãªã„æœˆã¯ã‚¹ã‚­ãƒƒãƒ—ï¼ˆç©ºæŠ•ä¸‹ã—ãªã„ï¼‰
        }, intervalMs);
      });
    </script>
  </body>
</html>
