<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®ãƒ‡ãƒ¼ã‚¿å–å¾—ï¼ˆã‚°ãƒŸç”¨ï¼‰</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Google Identity Services: OAuth 2.0 ãƒˆãƒ¼ã‚¯ãƒ³ ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ -->
    <script async defer src="https://accounts.google.com/gsi/client"></script>
    <style>
      body {
        font-family: system-ui, sans-serif;
        margin: 2rem;
      }
      button {
        padding: 0.8rem 1.2rem;
        font-size: 1rem;
      }
      #output {
        background: #f4f4f8;
        padding: 1rem;
        overflow: auto;
        max-height: 600px;
        border-radius: 4px;
      }
      .month-section {
        margin-bottom: 1.5rem;
      }
      details {
        background: white;
        border-radius: 4px;
        padding: 0.5rem;
        margin-bottom: 0.5rem;
      }
      summary {
        cursor: pointer;
        font-weight: bold;
        color: #2563eb;
        padding: 0.5rem;
        user-select: none;
      }
      summary:hover {
        background: #f0f9ff;
        border-radius: 4px;
      }
      .event-list {
        list-style: none;
        padding: 0;
        margin: 0.5rem 0 0 0;
      }
      .event-item {
        padding: 0.5rem;
        border-bottom: 1px solid #e0e0e0;
        font-family: monospace;
      }
      .event-item:last-child {
        border-bottom: none;
      }
      .event-date {
        color: #2563eb;
        font-weight: bold;
        margin-right: 1rem;
      }
      .event-title {
        color: #1f2937;
      }
    </style>
  </head>
  <body>
    <h1>ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹</h1>
    <p>
      å¹´ã‚’é¸æŠã—ã¦ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨ã€ãã®å¹´ã® Google Calendar
      ã‚¤ãƒ™ãƒ³ãƒˆã‚’å–å¾—ã—ã¾ã™ï¼ˆèª­ã¿å–ã‚Šå°‚ç”¨ï¼‰ã€‚
    </p>

    <div style="margin-bottom: 1rem">
      <label for="year-select">å¹´ã‚’é¸æŠ: </label>
      <select id="year-select" style="padding: 0.5rem; font-size: 1rem">
        <option value="2023">2023</option>
        <option value="2024">2024</option>
        <option value="2025" selected>2025</option>
        <option value="2026">2026</option>
      </select>
    </div>

    <button id="fetch-btn">ã‚«ãƒ¬ãƒ³ãƒ€ãƒ¼ã®ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã™ã‚‹</button>
    <button
      id="download-btn"
      style="
        display: none;
        margin-left: 0.5rem;
        background: #10b981;
        color: white;
      "
    >
      JSONãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰
    </button>
    <p id="status"></p>

    <div
      id="filter-section"
      style="
        display: none;
        margin: 1rem 0;
        padding: 1rem;
        background: #e0f2fe;
        border-radius: 4px;
      "
    >
      <h3 style="margin-top: 0">ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼</h3>
      <div
        style="display: flex; gap: 1rem; flex-wrap: wrap; align-items: center"
      >
        <input
          id="q"
          type="text"
          placeholder="ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ï¼ˆã‚¿ã‚¤ãƒˆãƒ«/èª¬æ˜/å ´æ‰€ï¼‰"
          style="padding: 0.5rem; font-size: 1rem; min-width: 250px"
        />
        <label style="display: flex; align-items: center; gap: 0.5rem">
          <input type="checkbox" id="allDayOnly" />
          <span>çµ‚æ—¥ã®äºˆå®šã®ã¿</span>
        </label>
        <button id="apply-filter" style="padding: 0.5rem 1rem">
          ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨
        </button>
        <button
          id="clear-filter"
          style="padding: 0.5rem 1rem; background: #e5e7eb"
        >
          ã‚¯ãƒªã‚¢
        </button>
      </div>
    </div>

    <div id="output"></div>

    <!-- ã‚°ãƒŸè½ä¸‹ãƒ‡ãƒ¢UI -->
    <div
      style="
        margin-top: 2rem;
        padding: 1rem;
        background: #fef3c7;
        border-radius: 4px;
      "
    >
      <h3 style="margin-top: 0">ã‚°ãƒŸå¯è¦–åŒ–</h3>
      <p style="margin: 0.5rem 0">
        è¡¨ç¤ºä¸­ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’ã‚°ãƒŸã«å¤‰æ›ã—ã¦è½ã¨ã—ã¾ã™ã€‚è‰²ã¯æ„Ÿæƒ…ã€ã‚µã‚¤ã‚ºã¯é‡ã¿ï¼ˆå‚åŠ è€…æ•°ãªã©ï¼‰ã‚’è¡¨ã—ã¾ã™ã€‚
      </p>
      <button
        id="drop-btn"
        style="
          padding: 0.8rem 1.2rem;
          background: #f59e0b;
          color: white;
          font-weight: bold;
        "
      >
        ã‚°ãƒŸã‚’è½ã¨ã™
      </button>
      <canvas
        id="gummy-canvas"
        width="900"
        height="500"
        style="
          border: 2px solid #d97706;
          margin-top: 0.5rem;
          display: block;
          border-radius: 4px;
          background: #fffbeb;
        "
      ></canvas>
    </div>

    <script type="module">
      // â˜…â˜… ã“ã“ã‚’æ›¸ãæ›ãˆã‚‹ â˜…â˜…
      const CLIENT_ID = import.meta.env.VITE_GOOGLE_CLIENT_ID; // Cloud Consoleã§ç™ºè¡Œã•ã‚ŒãŸã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆID
      const SCOPES = "https://www.googleapis.com/auth/calendar.readonly";

      // ä»Šå¹´ã®ç¯„å›²ã‚’ISOæ–‡å­—åˆ—ï¼ˆUTCï¼‰ã§ä½œæˆ
      function getYearRangeUTC(year = new Date().getFullYear()) {
        const timeMin = new Date(Date.UTC(year, 0, 1, 0, 0, 0)).toISOString();
        const timeMax = new Date(
          Date.UTC(year, 11, 31, 23, 59, 59)
        ).toISOString();
        return { timeMin, timeMax, year };
      }

      // çŠ¶æ…‹è¡¨ç¤ºç”¨
      const $status = document.getElementById("status");
      const $output = document.getElementById("output");
      const $btn = document.getElementById("fetch-btn");
      const $downloadBtn = document.getElementById("download-btn");
      const $yearSelect = document.getElementById("year-select");
      const $filterSection = document.getElementById("filter-section");
      const $applyFilter = document.getElementById("apply-filter");
      const $clearFilter = document.getElementById("clear-filter");
      const $q = document.getElementById("q");
      const $allDayOnly = document.getElementById("allDayOnly");

      let tokenClient = null;
      let accessToken = null;
      let pendingTokenRequest = null;
      let allEvents = []; // å–å¾—ã—ãŸå…¨ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä¿æŒ
      let currentDisplayedEvents = []; // ç¾åœ¨è¡¨ç¤ºä¸­ã®ã‚¤ãƒ™ãƒ³ãƒˆï¼ˆãƒ•ã‚£ãƒ«ã‚¿ãƒ¼å¾Œï¼‰

      function setStatus(msg) {
        $status.textContent = msg;
      }

      function formatEventDate(ev) {
        // çµ‚æ—¥äºˆå®š: start.date ã®ã¿å­˜åœ¨
        if (ev.start?.date && !ev.start?.dateTime) {
          return ev.start.date; // YYYY-MM-DD ã‚’ãã®ã¾ã¾è¿”ã™
        }
        // æ™‚é–“æŒ‡å®šäºˆå®š: start.dateTime å­˜åœ¨
        if (ev.start?.dateTime) {
          const d = new Date(ev.start.dateTime);
          const yyyy = d.getFullYear();
          const mm = String(d.getMonth() + 1).padStart(2, "0");
          const dd = String(d.getDate()).padStart(2, "0");
          return `${yyyy}-${mm}-${dd}`;
        }
        return "";
      }

      function groupByMonth(events) {
        const map = new Map(); // key: 'YYYY-MM', value: array of events
        for (const ev of events) {
          const dateStr = formatEventDate(ev);
          if (!dateStr) continue;
          const ym = dateStr.slice(0, 7); // YYYY-MM
          if (!map.has(ym)) map.set(ym, []);
          map.get(ym).push(ev);
        }
        return map;
      }

      function applyFilter(events) {
        const q = $q.value.trim().toLowerCase();
        const allDayOnly = $allDayOnly.checked;

        return events.filter((ev) => {
          // çµ‚æ—¥åˆ¤å®š: start.date ãŒã‚ã£ã¦ start.dateTime ãŒãªã„
          const isAllDay = !!ev.start?.date && !ev.start?.dateTime;
          if (allDayOnly && !isAllDay) return false;

          // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰æ¤œç´¢
          if (q) {
            const text = [
              ev.summary || "",
              ev.description || "",
              ev.location || "",
            ]
              .join(" ")
              .toLowerCase();
            if (!text.includes(q)) return false;
          }

          return true;
        });
      }

      function downloadJSON(data, filename = "calendar-events.json") {
        const blob = new Blob([JSON.stringify(data, null, 2)], {
          type: "application/json",
        });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.click();
        URL.revokeObjectURL(a.href);
      }

      function displayEvents(events) {
        currentDisplayedEvents = events; // ç¾åœ¨è¡¨ç¤ºä¸­ã®ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä¿å­˜

        if (events.length === 0) {
          $output.innerHTML =
            '<p style="color: #6b7280;">ã‚¤ãƒ™ãƒ³ãƒˆãŒã‚ã‚Šã¾ã›ã‚“</p>';
          return;
        }

        const monthly = groupByMonth(events);
        const months = Array.from(monthly.keys()).sort();

        const html = months
          .map((ym) => {
            const monthEvents = monthly.get(ym);
            const count = monthEvents.length;

            const eventItems = monthEvents
              .map((ev) => {
                const dateStr = formatEventDate(ev) || "æ—¥ä»˜ä¸æ˜";
                const title = ev.summary || "(ã‚¿ã‚¤ãƒˆãƒ«ãªã—)";
                // çµ‚æ—¥ã‹ã©ã†ã‹ã‚’è¡¨ç¤ºã«åæ˜ 
                const isAllDay = !!ev.start?.date && !ev.start?.dateTime;
                const timeMarker = isAllDay ? " [çµ‚æ—¥]" : "";

                return `<li class="event-item">
                <span class="event-date">${dateStr}</span> | <span class="event-title">${title}${timeMarker}</span>
              </li>`;
              })
              .join("");

            return `<section class="month-section">
            <details open>
              <summary>${ym} | ${count}ä»¶</summary>
              <ul class="event-list">
                ${eventItems}
              </ul>
            </details>
          </section>`;
          })
          .join("");

        $output.innerHTML = html;
      }

      function initTokenClient() {
        if (tokenClient) return;
        tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: CLIENT_ID,
          scope: SCOPES,
          callback: (resp) => {
            if (resp.error) {
              setStatus("èªè¨¼ã‚¨ãƒ©ãƒ¼: " + resp.error);
              console.error(resp);
              if (pendingTokenRequest) {
                pendingTokenRequest.reject(new Error(resp.error));
                pendingTokenRequest = null;
              }
            } else {
              accessToken = resp.access_token;
              if (pendingTokenRequest) {
                pendingTokenRequest.resolve(resp.access_token);
                pendingTokenRequest = null;
              }
            }
          },
        });
      }

      async function ensureAccessToken() {
        if (accessToken) return accessToken;

        // Initialize token client if needed
        if (!tokenClient) {
          initTokenClient();
        }

        // Create promise to wait for callback
        return new Promise((resolve, reject) => {
          pendingTokenRequest = { resolve, reject };

          // Check if already has token
          if (accessToken) {
            tokenClient.requestAccessToken({ prompt: "" });
          } else {
            tokenClient.requestAccessToken({ prompt: "consent" });
          }

          // Timeout after 60 seconds
          setTimeout(() => {
            if (pendingTokenRequest) {
              pendingTokenRequest.reject(
                new Error("èªè¨¼ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸ")
              );
              pendingTokenRequest = null;
            }
          }, 60000);
        });
      }

      async function fetchEventsForYear(year) {
        const { timeMin, timeMax } = getYearRangeUTC(year);
        const token = await ensureAccessToken();

        const params = new URLSearchParams({
          timeMin,
          timeMax,
          singleEvents: "true",
          orderBy: "startTime",
          maxResults: "2500", // å¹´é–“æœ€å¤§ä»¶æ•°ã®ç›®å®‰
        });

        const url = `https://www.googleapis.com/calendar/v3/calendars/primary/events?${params.toString()}`;
        const res = await fetch(url, {
          headers: { Authorization: `Bearer ${token}` },
        });

        if (!res.ok) {
          const errText = await res.text();
          throw new Error(`Calendar API ã‚¨ãƒ©ãƒ¼ (${res.status}): ${errText}`);
        }
        const data = await res.json();
        return data.items ?? [];
      }

      $btn.addEventListener("click", async () => {
        setStatus("èªè¨¼ã—ã¦ã„ã¾ã™â€¦");
        try {
          await ensureAccessToken();
          setStatus("ãƒ‡ãƒ¼ã‚¿å–å¾—ä¸­â€¦");
          const year = parseInt($yearSelect.value); // é¸æŠã•ã‚ŒãŸå¹´ã‚’å–å¾—
          const events = await fetchEventsForYear(year);
          allEvents = events; // å…¨ã‚¤ãƒ™ãƒ³ãƒˆã‚’ä¿å­˜
          setStatus(`å–å¾—å®Œäº†ï¼š${events.length}ä»¶ï¼ˆ${year}å¹´ï¼‰`);

          // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¨ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ã‚’è¡¨ç¤º
          $filterSection.style.display = "block";
          $downloadBtn.style.display = "inline-block";

          displayEvents(events);
        } catch (e) {
          console.error(e);
          setStatus("å¤±æ•—ï¼š" + e.message);
        }
      });

      $downloadBtn.addEventListener("click", () => {
        const year = parseInt($yearSelect.value);
        const filename = `calendar-events-${year}.json`;
        downloadJSON(currentDisplayedEvents, filename);
        setStatus(
          `ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰å®Œäº†ï¼š${currentDisplayedEvents.length}ä»¶ã‚’ ${filename} ã¨ã—ã¦ä¿å­˜`
        );
      });

      $applyFilter.addEventListener("click", () => {
        const filtered = applyFilter(allEvents);
        setStatus(
          `ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨ï¼š${filtered.length}ä»¶ / ${allEvents.length}ä»¶`
        );
        displayEvents(filtered);
      });

      $clearFilter.addEventListener("click", () => {
        $q.value = "";
        $allDayOnly.checked = false;
        setStatus(`å–å¾—å®Œäº†ï¼š${allEvents.length}ä»¶`);
        displayEvents(allEvents);
      });

      // Enterã‚­ãƒ¼ã§ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨
      $q.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          $applyFilter.click();
        }
      });

      // =========================
      // ã‚°ãƒŸè½ä¸‹æ©Ÿèƒ½
      // =========================

      // ====== æ„Ÿæƒ…ã‚¹ã‚³ã‚¢å¼·åŒ–ï¼ˆè¾æ›¸ï¼‹HSLï¼‰ ======

      // æ—¥æœ¬èªè¾æ›¸ï¼ˆå¿…è¦ã«å¿œã˜ã¦è‡ªç”±ã«è¿½åŠ ã—ã¦OKï¼‰
      const LEXICON = {
        joy: [
          /ã†ã‚Œã—ã„|å¬‰ã—ã„|æ¥½ã—ã„|ãƒãƒƒãƒ”ãƒ¼|æœ€é«˜|ã‚„ã£ãŸ|æ­“å–œ|ç¥|å‹åˆ©|é”æˆ|å……å®Ÿ|å–œã³/i,
          /ğŸ˜Š|ğŸ˜„|ğŸ¥³|âœ¨|ğŸ‰|ğŸŠ/,
        ],
        calm: [
          /ç©ã‚„ã‹|ä¼‘æ†©|ãƒªãƒ©ãƒƒã‚¯ã‚¹|è½ã¡ç€|é™ã‹|ã®ã‚“ã³ã‚Š|ç™’ã—|ç‘æƒ³|æ•£æ­©|æ¸©æ³‰|ã‚«ãƒ•ã‚§|å®‰å®š/i,
          /ğŸ˜Œ|ğŸŒ¿|ğŸ«–|â˜•|ğŸ›€|ğŸŒ™/,
        ],
        busy: [
          /å¿™|ä¿®ç¾…å ´|ç· åˆ‡|ç· ã‚åˆ‡ã‚Š|ãƒ‡ãƒƒãƒ‰ãƒ©ã‚¤ãƒ³|rush|ãƒã‚¿ãƒã‚¿|æ®‹æ¥­|å¯¾å¿œ|ãƒˆãƒ©ãƒ–ãƒ«|ç‚ä¸Š|ã¦ã‚“ã¦ã“èˆã„/i,
          /â°|ğŸ”¥|ğŸ’¦|ğŸ“ˆ/,
        ],
        focus: [
          /é›†ä¸­|æ²¡é ­|æ·±æ˜ã‚Š|ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°|å®Ÿè£…|è¨­è¨ˆ|ç ”ç©¶|è«–æ–‡|å­¦ç¿’|å‹‰å¼·|æ¼”ç¿’|ä½œæ¥­|åŸ·ç­†|ãƒ¬ãƒ“ãƒ¥ãƒ¼|ãƒ†ã‚¹ãƒˆ/i,
          /ğŸ¯|ğŸ§ |ğŸ§ª|âŒ¨ï¸|ğŸ“/,
        ],
        stress: [
          /ã‚¹ãƒˆãƒ¬ã‚¹|ç–²åŠ´|ç„¦ã‚Š|ä¸å®‰|ãƒŸã‚¹|å¤±æ•—|æ€’ã‚Š|ã„ã‚‰ã„ã‚‰|æ‚²|ã¤ã‚‰|è½ã¡è¾¼|ã—ã‚“ã©|æ†‚é¬±/i,
          /ğŸ˜£|ğŸ˜¡|ğŸ˜¢|ğŸ’€|ğŸŒ€/,
        ],
      };

      // æ„Ÿæƒ…ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ï¼šãƒ†ã‚­ã‚¹ãƒˆ â†’ {joy, calm, busy, focus, stress, intensity}
      function scoreEmotion(text) {
        const lower = text.toLowerCase();
        const scores = { joy: 0, calm: 0, busy: 0, focus: 0, stress: 0 };

        for (const [key, patterns] of Object.entries(LEXICON)) {
          for (const re of patterns) {
            // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒè¤‡æ•°å›å‡ºã‚‹ã»ã©ã‚¹ã‚³ã‚¢åŠ ç®—
            const matches = lower.match(re);
            if (matches) scores[key] += matches.length;
          }
        }

        // ï¼ã‚„çµµæ–‡å­—ã®å¼·åº¦è£œæ­£ï¼ˆç°¡æ˜“ï¼‰
        const emphasis = text.match(/[!ï¼]/g)?.length || 0;
        const emojiBoost =
          (text.match(/[\u{1F300}-\u{1FAFF}]/gu)?.length || 0) * 0.5;
        const boost = Math.min(3, emphasis * 0.2 + emojiBoost);

        for (const k of Object.keys(scores)) scores[k] += boost;

        // ç·å¼·åº¦ï¼ˆæœ€å¤§ï¼‰ã‚’ 0..1 ã«æ­£è¦åŒ–
        const maxScore = Math.max(...Object.values(scores));
        const intensity = Math.min(1, maxScore / 5); // ã ã„ãŸã„5å›å‡ºç¾ã§å¼·ã‚æ‰±ã„
        return { ...scores, intensity };
      }

      // HSLãƒãƒƒãƒ”ãƒ³ã‚°ï¼šå„æ„Ÿæƒ…è»¸ã®è‰²ç›¸ã‚’ãƒ™ã‚¯ãƒˆãƒ«å¹³å‡ â†’ é€£ç¶šHue
      const BASE_HUE = {
        joy: 50, // é»„
        calm: 200, // é’
        busy: 0, // èµ¤
        focus: 120, // ç·‘
        stress: 300, // ãƒã‚¼ãƒ³ã‚¿
      };

      // Hueãƒ™ã‚¯ãƒˆãƒ«å¹³å‡ï¼ˆå††ç’°è£œæ­£ã‚ã‚Šï¼‰ã€å½©åº¦/æ˜åº¦ã¯æ–‡è„ˆã§èª¿æ•´
      function colorFromEmotionScores(scores, ctx = {}) {
        // ctx: { isAllDay, attendees, durationHours }
        const weights = Object.entries(scores)
          .filter(([k]) => k in BASE_HUE)
          .map(([k, v]) => ({ k, w: v }));

        const totalW = weights.reduce((a, b) => a + b.w, 0) || 1;
        // ãƒ™ã‚¯ãƒˆãƒ«å’Œï¼ˆå††ç’°ï¼‰
        let vx = 0,
          vy = 0;
        for (const { k, w } of weights) {
          const hue = (BASE_HUE[k] * Math.PI) / 180;
          vx += Math.cos(hue) * (w / totalW);
          vy += Math.sin(hue) * (w / totalW);
        }
        let hueDeg = (Math.atan2(vy, vx) * 180) / Math.PI;
        if (hueDeg < 0) hueDeg += 360;

        // å½©åº¦ï¼šå¼·åº¦ãƒ™ãƒ¼ã‚¹ï¼ˆå¼±â†’0.35, å¼·â†’0.9ï¼‰
        const s = 0.35 + scores.intensity * 0.55;

        // æ˜åº¦ï¼šçµ‚æ—¥ã¯æ˜ã‚‹ã‚ã€å‚åŠ è€…å¤šã„ï¼†é•·æ™‚é–“ã¯æš—ã‚
        const isAllDay = !!ctx.isAllDay;
        const attendees = Math.min(10, ctx.attendees || 0);
        const duration = Math.min(12, ctx.durationHours || 0);
        let l = isAllDay ? 0.65 : 0.55;
        l -= attendees * 0.015; // å¤šäººæ•°ã»ã©å°‘ã—æš—ã
        l -= duration * 0.01; // é•·æ™‚é–“ã»ã©å°‘ã—æš—ã
        l = Math.max(0.3, Math.min(0.75, l));

        return hslToHex(hueDeg, s, l);
      }

      // HSL â†’ HEX
      function hslToHex(h, s, l) {
        s = Math.max(0, Math.min(1, s));
        l = Math.max(0, Math.min(1, l));
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const hp = (h % 360) / 60;
        const x = c * (1 - Math.abs((hp % 2) - 1));
        let r1 = 0,
          g1 = 0,
          b1 = 0;
        if (0 <= hp && hp < 1) {
          r1 = c;
          g1 = x;
          b1 = 0;
        } else if (1 <= hp && hp < 2) {
          r1 = x;
          g1 = c;
          b1 = 0;
        } else if (2 <= hp && hp < 3) {
          r1 = 0;
          g1 = c;
          b1 = x;
        } else if (3 <= hp && hp < 4) {
          r1 = 0;
          g1 = x;
          b1 = c;
        } else if (4 <= hp && hp < 5) {
          r1 = x;
          g1 = 0;
          b1 = c;
        } else {
          r1 = c;
          g1 = 0;
          b1 = x;
        }
        const m = l - c / 2;
        const r = Math.round((r1 + m) * 255);
        const g = Math.round((g1 + m) * 255);
        const b = Math.round((b1 + m) * 255);
        return `#${[r, g, b]
          .map((v) => v.toString(16).padStart(2, "0"))
          .join("")}`;
      }

      // === toGummies ã‚’å¼·åŒ–ï¼ˆè¾æ›¸ã‚¹ã‚³ã‚¢â†’HSLè‰²ï¼‰ ===
      function toGummies(events) {
        return events.map((ev) => {
          const title = ev.summary || "";
          const text = [title, ev.description || "", ev.location || ""].join(
            " "
          );
          const isAllDay = !!ev.start?.date && !ev.start?.dateTime;
          const attendees = ev.attendees?.length || 0;

          // æ‰€è¦æ™‚é–“ï¼ˆæ™‚é–“ï¼‰
          let durationHours = 0;
          if (ev.start?.dateTime && ev.end?.dateTime) {
            const start = new Date(ev.start.dateTime).getTime();
            const end = new Date(ev.end.dateTime).getTime();
            durationHours = Math.max(0, (end - start) / 3600000);
          }

          const scores = scoreEmotion(text);
          const color = colorFromEmotionScores(scores, {
            isAllDay,
            attendees,
            durationHours,
          });

          // ç¨®åˆ¥ï¼ˆç°¡æ˜“ã‚«ãƒ†ã‚´ãƒªï¼›å¿…è¦ãªã‚‰è¾æ›¸æ‹¡å¼µï¼‰
          const lower = text.toLowerCase();
          const kind = /mtg|ä¼šè­°|meeting/.test(lower)
            ? "meeting"
            : /å‹‰å¼·|è¬›ç¾©|study|learn/.test(lower)
            ? "study"
            : /é–‹ç™º|å®Ÿè£…|ã‚³ãƒ¼ãƒ‰|code|task|ä½œæ¥­|èª²é¡Œ/.test(lower)
            ? "work"
            : /ä¼‘æš‡|æ—…è¡Œ|å®¶æ—|è²·ã„ç‰©|ç”Ÿæ´»|life/.test(lower)
            ? "life"
            : "other";

          // é‡ã¿ï¼šçµ‚æ—¥ãƒ»å‚åŠ è€…æ•°ãƒ»æ‰€è¦æ™‚é–“ã‚’è€ƒæ…®ï¼ˆç²’ã‚µã‚¤ã‚ºãƒ»è³ªé‡ï¼‰
          const baseWeight = isAllDay ? 0.9 : 1.0;
          const weight = Math.min(
            4,
            baseWeight +
              Math.log2(attendees + 1) +
              Math.min(1.5, durationHours / 6)
          );

          return {
            id: ev.id,
            date: formatEventDate(ev),
            kind,
            title,
            emotionScores: scores, // å¾Œã§UIã«è¡¨ç¤ºã§ãã‚‹
            color,
            weight,
          };
        });
      }

      // ä¹±æ•°ï¼ˆæ­£è¦åˆ†å¸ƒï¼‰Box-Muller
      function randNormal(mean = 0, stdDev = 1) {
        const u = 1 - Math.random();
        const v = 1 - Math.random();
        const z = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
        return mean + z * stdDev;
      }

      // ====== è¡çªã‚ã‚Šè½ä¸‹ï¼ˆä¸­å¤®ã‚¹ãƒãƒ¼ãƒ³ï¼†å±±ï¼‰ ======
      function dropGummies(gummies, options = {}) {
        const canvas = document.getElementById("gummy-canvas");
        /** @type {CanvasRenderingContext2D} */
        const ctx = canvas.getContext("2d");
        const W = canvas.width;
        const H = canvas.height;

        // ã‚ªãƒ—ã‚·ãƒ§ãƒ³
        const cfg = {
          gravity: 0.45,
          air: 0.995,
          restitution: 0.22, // åç™ºä¿‚æ•°
          frictionTangent: 0.02,
          centerBias: 0.12, // ä¸­å¤®å¯„ã›ï¼ˆæ­£è¦åˆ†å¸ƒã®æ¨™æº–åå·®ï¼›ç”»é¢å¹…ã«å¯¾ã™ã‚‹å‰²åˆï¼‰
          maxParticles: 600,
          ...options,
        };

        // æ—¢å­˜ã‚¢ãƒ‹ãƒ¡ãŒã‚ã‚‹å ´åˆã«æ­¢ã‚ã‚‹
        if (window.__gummyRAF) cancelAnimationFrame(window.__gummyRAF);

        // ã‚¹ãƒãƒ¼ãƒ³ï¼ˆä¸­å¤®å¯„ã›ï¼‰
        const cx = W / 2;
        const sigmaX = W * cfg.centerBias;
        const particles = gummies.slice(0, cfg.maxParticles).map((g) => {
          const x = Math.max(20, Math.min(W - 20, cx + randNormal(0, sigmaX)));
          return {
            x,
            y: -Math.random() * 200 - 10,
            vx: (Math.random() - 0.5) * 0.2,
            vy: 0,
            r: Math.max(6, 5 + g.weight * 3),
            m: Math.max(1, g.weight), // è³ªé‡
            color: g.color,
            kind: g.kind,
            scores: g.emotionScores,
          };
        });

        // åºŠãƒ»å£
        const floorY = H - 10;
        const leftX = 0,
          rightX = W;

        // ã‚°ãƒªãƒƒãƒ‰ï¼ˆåºƒç›¸ï¼‰
        const cellSize = 24;
        const neighbors = [
          [0, 0],
          [1, 0],
          [0, 1],
          [1, 1],
          [-1, 0],
          [0, -1],
          [-1, -1],
          [1, -1],
          [-1, 1],
        ];

        function buildGrid() {
          const grid = new Map(); // key "ix,iy" -> indices[]
          for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            const ix = Math.floor(p.x / cellSize);
            const iy = Math.floor(p.y / cellSize);
            const key = `${ix},${iy}`;
            let arr = grid.get(key);
            if (!arr) {
              arr = [];
              grid.set(key, arr);
            }
            arr.push(i);
          }
          return grid;
        }

        function resolvePair(p, q) {
          const dx = q.x - p.x;
          const dy = q.y - p.y;
          const dist2 = dx * dx + dy * dy;
          const rSum = p.r + q.r;
          if (dist2 <= 0) return;

          if (dist2 < rSum * rSum) {
            const dist = Math.sqrt(dist2) || 0.0001;
            const nx = dx / dist,
              ny = dy / dist; // æ³•ç·š
            const overlap = rSum - dist;

            // ä½ç½®ä¿®æ­£ï¼ˆè³ªé‡ã«å¿œã˜ã¦ï¼‰
            const totalM = p.m + q.m;
            const pushP = overlap * (q.m / totalM);
            const pushQ = overlap * (p.m / totalM);
            p.x -= nx * pushP;
            p.y -= ny * pushP;
            q.x += nx * pushQ;
            q.y += ny * pushQ;

            // é€Ÿåº¦ã‚¤ãƒ³ãƒ‘ãƒ«ã‚¹ï¼ˆåç™ºï¼‰
            const rvx = q.vx - p.vx;
            const rvy = q.vy - p.vy;
            const relN = rvx * nx + rvy * ny;
            if (relN < 0) {
              const e = cfg.restitution;
              const j = (-(1 + e) * relN) / (1 / p.m + 1 / q.m);
              const jx = j * nx,
                jy = j * ny;
              p.vx -= jx / p.m;
              p.vy -= jy / p.m;
              q.vx += jx / q.m;
              q.vy += jy / q.m;

              // ã–ã£ãã‚Šæ‘©æ“¦ï¼ˆæ¥ç·šæ–¹å‘ã‚’å°‘ã—æ¸›è¡°ï¼‰
              const tx = -ny,
                ty = nx; // æ¥ç·š
              const relT = rvx * tx + rvy * ty;
              const jt = Math.max(
                -cfg.frictionTangent,
                Math.min(cfg.frictionTangent, relT)
              );
              const jtx = jt * tx,
                jty = jt * ty;
              p.vx -= jtx / p.m;
              p.vy -= jty / p.m;
              q.vx += jtx / q.m;
              q.vy += jty / q.m;
            }
          }
        }

        function physicsStep(dt = 1) {
          // é‡åŠ›ãƒ»ç©ºæ°—æŠµæŠ—ãƒ»ç§»å‹•
          for (const p of particles) {
            p.vy += cfg.gravity * dt;
            p.vx *= cfg.air;
            p.vy *= cfg.air;
            p.x += p.vx * dt;
            p.y += p.vy * dt;

            // å£ãƒ»åºŠ
            if (p.x - p.r < leftX) {
              p.x = leftX + p.r;
              p.vx *= -cfg.restitution;
            } else if (p.x + p.r > rightX) {
              p.x = rightX - p.r;
              p.vx *= -cfg.restitution;
            }
            if (p.y + p.r > floorY) {
              p.y = floorY - p.r;
              p.vy *= -cfg.restitution;
              if (Math.abs(p.vy) < 0.3) p.vy = 0; // è½ã¡ç€ã‹ã›ã‚‹
            }
          }

          // è¡çªï¼ˆã‚°ãƒªãƒƒãƒ‰è¿‘å‚ï¼‰
          const grid = buildGrid();
          for (const [key, indices] of grid.entries()) {
            const [ix, iy] = key.split(",").map(Number);
            for (const [dx, dy] of neighbors) {
              const nk = `${ix + dx},${iy + dy}`;
              const neigh = grid.get(nk);
              if (!neigh) continue;
              for (const i of indices) {
                for (const j of neigh) {
                  if (j <= i) continue;
                  resolvePair(particles[i], particles[j]);
                }
              }
            }
          }
        }

        function draw() {
          ctx.clearRect(0, 0, W, H);
          // åºŠè¡¨ç¤º
          ctx.fillStyle = "#eee";
          ctx.fillRect(0, floorY, W, H - floorY);

          // ç²’æç”»
          for (const p of particles) {
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.fill();

            // ã·ã«ã£ã¨ãƒã‚¤ãƒ©ã‚¤ãƒˆ
            ctx.fillStyle = "rgba(255,255,255,0.35)";
            ctx.beginPath();
            ctx.arc(
              p.x - p.r * 0.4,
              p.y - p.r * 0.45,
              p.r * 0.28,
              0,
              Math.PI * 2
            );
            ctx.fill();
          }
        }

        function loop() {
          physicsStep(1);
          draw();
          window.__gummyRAF = requestAnimationFrame(loop);
        }
        loop();
      }

      // UIã®ã‚¤ãƒ™ãƒ³ãƒˆé…ç·š
      const $dropBtn = document.getElementById("drop-btn");

      $dropBtn.addEventListener("click", () => {
        const events = currentDisplayedEvents || [];
        if (!events.length) {
          alert(
            "è½ã¨ã™ã‚¤ãƒ™ãƒ³ãƒˆãŒã‚ã‚Šã¾ã›ã‚“ã€‚ã¾ãšã¯å–å¾—ï¼†ï¼ˆå¿…è¦ãªã‚‰ï¼‰ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã—ã¦ã­ã€‚"
          );
          return;
        }
        const gummies = toGummies(events);
        dropGummies(gummies, {
          centerBias: 0.12, // ã‚ˆã‚Šä¸­å¤®å¯„ã›ã«
          restitution: 0.22,
        });
        setStatus(`ã‚°ãƒŸç”Ÿæˆå®Œäº†ï¼š${gummies.length}å€‹ã®ã‚°ãƒŸã‚’è½ã¨ã—ã¾ã—ãŸï¼`);
      });
    </script>
  </body>
</html>
