<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>カレンダーのデータ取得（グミ用）</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <!-- Google Identity Services: OAuth 2.0 トークン クライアント -->
    <script async defer src="https://accounts.google.com/gsi/client"></script>
    <style>
      body {
        font-family: system-ui, sans-serif;
        margin: 2rem;
      }
      button {
        padding: 0.8rem 1.2rem;
        font-size: 1rem;
      }
      #output {
        background: #f4f4f8;
        padding: 1rem;
        overflow: auto;
        max-height: 600px;
        border-radius: 4px;
      }
      .month-section {
        margin-bottom: 1.5rem;
      }
      details {
        background: white;
        border-radius: 4px;
        padding: 0.5rem;
        margin-bottom: 0.5rem;
      }
      summary {
        cursor: pointer;
        font-weight: bold;
        color: #2563eb;
        padding: 0.5rem;
        user-select: none;
      }
      summary:hover {
        background: #f0f9ff;
        border-radius: 4px;
      }
      .event-list {
        list-style: none;
        padding: 0;
        margin: 0.5rem 0 0 0;
      }
      .event-item {
        padding: 0.5rem;
        border-bottom: 1px solid #e0e0e0;
        font-family: monospace;
      }
      .event-item:last-child {
        border-bottom: none;
      }
      .event-date {
        color: #2563eb;
        font-weight: bold;
        margin-right: 1rem;
      }
      .event-title {
        color: #1f2937;
      }
    </style>
  </head>
  <body>
    <h1>カレンダーのデータを取得する</h1>
    <p>
      年を選択してボタンを押すと、その年の Google Calendar
      イベントを取得します（読み取り専用）。
    </p>

    <div style="margin-bottom: 1rem">
      <label for="year-select">年を選択: </label>
      <select id="year-select" style="padding: 0.5rem; font-size: 1rem">
        <option value="2023">2023</option>
        <option value="2024">2024</option>
        <option value="2025" selected>2025</option>
        <option value="2026">2026</option>
      </select>
    </div>

    <button id="fetch-btn">カレンダーのデータを取得する</button>
    <button
      id="download-btn"
      style="
        display: none;
        margin-left: 0.5rem;
        background: #10b981;
        color: white;
      "
    >
      JSONダウンロード
    </button>
    <p id="status"></p>

    <div
      id="filter-section"
      style="
        display: none;
        margin: 1rem 0;
        padding: 1rem;
        background: #e0f2fe;
        border-radius: 4px;
      "
    >
      <h3 style="margin-top: 0">フィルター</h3>
      <div
        style="display: flex; gap: 1rem; flex-wrap: wrap; align-items: center"
      >
        <input
          id="q"
          type="text"
          placeholder="キーワード（タイトル/説明/場所）"
          style="padding: 0.5rem; font-size: 1rem; min-width: 250px"
        />
        <label style="display: flex; align-items: center; gap: 0.5rem">
          <input type="checkbox" id="allDayOnly" />
          <span>終日の予定のみ</span>
        </label>
        <button id="apply-filter" style="padding: 0.5rem 1rem">
          フィルター適用
        </button>
        <button
          id="clear-filter"
          style="padding: 0.5rem 1rem; background: #e5e7eb"
        >
          クリア
        </button>
      </div>
    </div>

    <div id="output"></div>

    <script type="module">
      // ★★ ここを書き換える ★★
      const CLIENT_ID = import.meta.env.VITE_GOOGLE_CLIENT_ID; // Cloud Consoleで発行されたクライアントID
      const SCOPES = "https://www.googleapis.com/auth/calendar.readonly";

      // 今年の範囲をISO文字列（UTC）で作成
      function getYearRangeUTC(year = new Date().getFullYear()) {
        const timeMin = new Date(Date.UTC(year, 0, 1, 0, 0, 0)).toISOString();
        const timeMax = new Date(
          Date.UTC(year, 11, 31, 23, 59, 59)
        ).toISOString();
        return { timeMin, timeMax, year };
      }

      // 状態表示用
      const $status = document.getElementById("status");
      const $output = document.getElementById("output");
      const $btn = document.getElementById("fetch-btn");
      const $downloadBtn = document.getElementById("download-btn");
      const $yearSelect = document.getElementById("year-select");
      const $filterSection = document.getElementById("filter-section");
      const $applyFilter = document.getElementById("apply-filter");
      const $clearFilter = document.getElementById("clear-filter");
      const $q = document.getElementById("q");
      const $allDayOnly = document.getElementById("allDayOnly");

      let tokenClient = null;
      let accessToken = null;
      let pendingTokenRequest = null;
      let allEvents = []; // 取得した全イベントを保持
      let currentDisplayedEvents = []; // 現在表示中のイベント（フィルター後）

      function setStatus(msg) {
        $status.textContent = msg;
      }

      function formatEventDate(ev) {
        // 終日予定: start.date のみ存在
        if (ev.start?.date && !ev.start?.dateTime) {
          return ev.start.date; // YYYY-MM-DD をそのまま返す
        }
        // 時間指定予定: start.dateTime 存在
        if (ev.start?.dateTime) {
          const d = new Date(ev.start.dateTime);
          const yyyy = d.getFullYear();
          const mm = String(d.getMonth() + 1).padStart(2, "0");
          const dd = String(d.getDate()).padStart(2, "0");
          return `${yyyy}-${mm}-${dd}`;
        }
        return "";
      }

      function groupByMonth(events) {
        const map = new Map(); // key: 'YYYY-MM', value: array of events
        for (const ev of events) {
          const dateStr = formatEventDate(ev);
          if (!dateStr) continue;
          const ym = dateStr.slice(0, 7); // YYYY-MM
          if (!map.has(ym)) map.set(ym, []);
          map.get(ym).push(ev);
        }
        return map;
      }

      function applyFilter(events) {
        const q = $q.value.trim().toLowerCase();
        const allDayOnly = $allDayOnly.checked;

        return events.filter((ev) => {
          // 終日判定: start.date があって start.dateTime がない
          const isAllDay = !!ev.start?.date && !ev.start?.dateTime;
          if (allDayOnly && !isAllDay) return false;

          // キーワード検索
          if (q) {
            const text = [
              ev.summary || "",
              ev.description || "",
              ev.location || "",
            ]
              .join(" ")
              .toLowerCase();
            if (!text.includes(q)) return false;
          }

          return true;
        });
      }

      function downloadJSON(data, filename = "calendar-events.json") {
        const blob = new Blob([JSON.stringify(data, null, 2)], {
          type: "application/json",
        });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        a.click();
        URL.revokeObjectURL(a.href);
      }

      function displayEvents(events) {
        currentDisplayedEvents = events; // 現在表示中のイベントを保存

        if (events.length === 0) {
          $output.innerHTML =
            '<p style="color: #6b7280;">イベントがありません</p>';
          return;
        }

        const monthly = groupByMonth(events);
        const months = Array.from(monthly.keys()).sort();

        const html = months
          .map((ym) => {
            const monthEvents = monthly.get(ym);
            const count = monthEvents.length;

            const eventItems = monthEvents
              .map((ev) => {
                const dateStr = formatEventDate(ev) || "日付不明";
                const title = ev.summary || "(タイトルなし)";
                // 終日かどうかを表示に反映
                const isAllDay = !!ev.start?.date && !ev.start?.dateTime;
                const timeMarker = isAllDay ? " [終日]" : "";

                return `<li class="event-item">
                <span class="event-date">${dateStr}</span> | <span class="event-title">${title}${timeMarker}</span>
              </li>`;
              })
              .join("");

            return `<section class="month-section">
            <details open>
              <summary>${ym} | ${count}件</summary>
              <ul class="event-list">
                ${eventItems}
              </ul>
            </details>
          </section>`;
          })
          .join("");

        $output.innerHTML = html;
      }

      function initTokenClient() {
        if (tokenClient) return;
        tokenClient = google.accounts.oauth2.initTokenClient({
          client_id: CLIENT_ID,
          scope: SCOPES,
          callback: (resp) => {
            if (resp.error) {
              setStatus("認証エラー: " + resp.error);
              console.error(resp);
              if (pendingTokenRequest) {
                pendingTokenRequest.reject(new Error(resp.error));
                pendingTokenRequest = null;
              }
            } else {
              accessToken = resp.access_token;
              if (pendingTokenRequest) {
                pendingTokenRequest.resolve(resp.access_token);
                pendingTokenRequest = null;
              }
            }
          },
        });
      }

      async function ensureAccessToken() {
        if (accessToken) return accessToken;

        // Initialize token client if needed
        if (!tokenClient) {
          initTokenClient();
        }

        // Create promise to wait for callback
        return new Promise((resolve, reject) => {
          pendingTokenRequest = { resolve, reject };

          // Check if already has token
          if (accessToken) {
            tokenClient.requestAccessToken({ prompt: "" });
          } else {
            tokenClient.requestAccessToken({ prompt: "consent" });
          }

          // Timeout after 60 seconds
          setTimeout(() => {
            if (pendingTokenRequest) {
              pendingTokenRequest.reject(
                new Error("認証がタイムアウトしました")
              );
              pendingTokenRequest = null;
            }
          }, 60000);
        });
      }

      async function fetchEventsForYear(year) {
        const { timeMin, timeMax } = getYearRangeUTC(year);
        const token = await ensureAccessToken();

        const params = new URLSearchParams({
          timeMin,
          timeMax,
          singleEvents: "true",
          orderBy: "startTime",
          maxResults: "2500", // 年間最大件数の目安
        });

        const url = `https://www.googleapis.com/calendar/v3/calendars/primary/events?${params.toString()}`;
        const res = await fetch(url, {
          headers: { Authorization: `Bearer ${token}` },
        });

        if (!res.ok) {
          const errText = await res.text();
          throw new Error(`Calendar API エラー (${res.status}): ${errText}`);
        }
        const data = await res.json();
        return data.items ?? [];
      }

      $btn.addEventListener("click", async () => {
        setStatus("認証しています…");
        try {
          await ensureAccessToken();
          setStatus("データ取得中…");
          const year = parseInt($yearSelect.value); // 選択された年を取得
          const events = await fetchEventsForYear(year);
          allEvents = events; // 全イベントを保存
          setStatus(`取得完了：${events.length}件（${year}年）`);

          // フィルターセクションとダウンロードボタンを表示
          $filterSection.style.display = "block";
          $downloadBtn.style.display = "inline-block";

          displayEvents(events);
        } catch (e) {
          console.error(e);
          setStatus("失敗：" + e.message);
        }
      });

      $downloadBtn.addEventListener("click", () => {
        const year = parseInt($yearSelect.value);
        const filename = `calendar-events-${year}.json`;
        downloadJSON(currentDisplayedEvents, filename);
        setStatus(
          `ダウンロード完了：${currentDisplayedEvents.length}件を ${filename} として保存`
        );
      });

      $applyFilter.addEventListener("click", () => {
        const filtered = applyFilter(allEvents);
        setStatus(
          `フィルター適用：${filtered.length}件 / ${allEvents.length}件`
        );
        displayEvents(filtered);
      });

      $clearFilter.addEventListener("click", () => {
        $q.value = "";
        $allDayOnly.checked = false;
        setStatus(`取得完了：${allEvents.length}件`);
        displayEvents(allEvents);
      });

      // Enterキーでフィルター適用
      $q.addEventListener("keypress", (e) => {
        if (e.key === "Enter") {
          $applyFilter.click();
        }
      });
    </script>
  </body>
</html>
